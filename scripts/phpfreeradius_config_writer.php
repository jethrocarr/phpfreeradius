<?php
/*
	phpfreeradius_config_writer

	Connects to phpfreeradius and fetching NAS/Huntgroup configuration which
	is then written to the filesystem.


	Copyright (c) 2010 Amberdms Ltd

	Licensed under the GNU AGPL.
*/



/*
	CONFIGURATION
*/

require("include/config.php");
require("include/amberphplib/main.php");




/*
	Verify that the FreeRadius files are writable
*/
if (!is_writable($GLOBALS["config"]["freeradius_file_clients"]))
{
	log_write("error", "script", "Unable to write to FreeRadius configuration file ". $GLOBALS["config"]["freeradius_file_clients"]);
	die("Fatal Error");
}

if (!is_writable($GLOBALS["config"]["freeradius_file_huntgroups"]))
{
	log_write("error", "script", "Unable to write to FreeRadius huntgroups file ". $GLOBALS["config"]["freeradius_file_huntgroups"]);
	die("Fatal Error");
}

if (!is_writable($GLOBALS["config"]["freeradius_file_users"]))
{
	log_write("error", "script", "Unable to write to FreeRadius users file ". $GLOBALS["config"]["freeradius_file_users"]);
	die("Fatal Error");
}




/*
	Initiate connection & authenticate to phpfreeradius

*/
$client = new SoapClient($GLOBALS["config"]["api_url"] ."/phpfreeradius.wsdl");
$client->__setLocation($GLOBALS["config"]["api_url"] ."/phpfreeradius.php");


// login & get PHP session ID
try
{
	log_write("debug", "script", "Authenticating with API as radius server ". $GLOBALS["config"]["api_server_name"] ."...");

	if ($client->authenticate($GLOBALS["config"]["api_server_name"], $GLOBALS["config"]["api_auth_key"]))
	{
		log_write("debug", "script", "Authentication successful");
	}

}
catch (SoapFault $exception)
{
	if ($exception->getMessage() == "ACCESS_DENIED")
	{
		log_write("error", "script", "Unable to authenticate with phpfreeradius API - check that auth API key and server name are valid");
		die("Fatal Error");
	}
	else
	{	
		log_write("error", "script", "Unknown failure whilst attempting to authenticate with the API - ". $exception->getMessage() ."");
		die("Fatal Error");
	}
}



/*
	Find out if any config has changed
*/
try
{
	if (!$config_version = $client->check_update_version())
	{
		// all good
		log_write("debug", "script", "System configuration is uptodate, no changes nessacary");
		exit(0);
	}
	else
	{
		/*
			Configuration is out of date - we need to fetch all the NAS records
		*/

		log_write("debug", "script", "Configuration is out of date, fetching new NAS configuration version $config_version via API");

		$data_nas = $client->fetch_nas_config();
	}
}
catch (SoapFault $exception)
{
	log_write("error", "script", "An unexpected error occured ". $exception->getMessage() ."");
	die("Fatal Error");
}




/*
	Write Configuration

	Need to generate:
	- NAS/clients
	- Huntgroups
	- Users
*/




/*
	NAS CONFIGURATION FILE
*/
log_write("debug", "script", "Writing NAS configuration file ". $GLOBALS["config"]["freeradius_file_clients"] ."");

if (!$fh = fopen($GLOBALS["config"]["freeradius_file_clients"], "w"))
{
	log_write("error", "main", "Unable to open file ". $GLOBALS["config"]["freeradius_file_clients"] ." for writing");
	die("Fatal Error");
}

fwrite($fh, "#\n");
fwrite($fh, "# FREERADIUS NAS CONFIGURATION\n");
fwrite($fh, "# automatically generated by phpfreeradius - do not manually adjust as changes will be lost\n");
fwrite($fh, "#\n");
fwrite($fh, "# application version ". $GLOBALS["config"]["app_version"] . " configuration version $config_version\n");
fwrite($fh, "#\n");
fwrite($fh, "\n");

foreach ($data_nas as $nas)
{
	log_write("debug", "main", "Process NAS ". $nas["nas_hostname"] ."");

	fwrite($fh, "# ". $nas["nas_hostname"] ."\n");

	// check shortname
	if ($nas["nas_shortname"] == "")
	{
		// the shortname feature was introduced at a later stage, not all hosts will
		// have a shortname - if they don't, it doesn't matter, just means we need to
		// go and set the shortname to the same as the hostname
		$nas["nas_shortname"] = $nas["nas_hostname"];
	}


	// make sure we don't break on description newlines
	$nas["nas_description"] = preg_replace("/\r/", "", $nas["nas_description"]);
	$nas["nas_description"] = preg_replace("/\n/", "\n# ", $nas["nas_description"]);

	fwrite($fh, "# ". $nas["nas_description"] ."\n");

	// general host settings
	fwrite($fh, "#\n");
	fwrite($fh, "client ". $nas["nas_address"] ." {\n");	
	fwrite($fh, "\tsecret = ". $nas["nas_secret"] ."\n");
	fwrite($fh, "\tshortname = ". $nas["nas_shortname"] ."\n");
	fwrite($fh, "\tnastype = ". $nas["nas_type"] ."\n");
	fwrite($fh, "}\n");
	fwrite($fh, "\n");
}		        

fclose($fh);



/*
	HUNTGROUP CONFIGURATION FILE
*/
log_write("debug", "script", "Writing huntgroup configuration file ". $GLOBALS["config"]["freeradius_file_huntgroups"] ."");

if (!$fh = fopen($GLOBALS["config"]["freeradius_file_huntgroups"], "w"))
{
	log_write("error", "main", "Unable to open file ". $GLOBALS["config"]["freeradius_file_huntgroups"] ." for writing");
	die("Fatal Error");
}

fwrite($fh, "#\n");
fwrite($fh, "# FREERADIUS HUNTGROUPS CONFIGURATION\n");
fwrite($fh, "# automatically generated by phpfreeradius - do not manually adjust as changes will be lost\n");
fwrite($fh, "#\n");
fwrite($fh, "# application version ". $GLOBALS["config"]["app_version"] . " configuration version $config_version\n");
fwrite($fh, "#\n");
fwrite($fh, "\n");

foreach ($data_nas as $nas)
{
	log_write("debug", "main", "Process Huntgroups for ". $nas["nas_hostname"] ."");

	/*
		Determine NAS IP/Hostname
	*/

	// determine the type of address
	if (preg_match("/^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:[.](?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$/", $nas["nas_address"]))
	{
		// single IP, write a rule
		fwrite($fh, $nas["nas_ldapgroup"] . "\tNAS-IP-Address == ". $nas["nas_address"] ."\n");
	}
	elseif (preg_match("/^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:[.](?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}\/[0-9]*$/", $nas["nas_address"]))
	{
		// subnet in CIDR notation
		// we need to calculate all the IP addresses in this subnet and then write them all to the configuration file

		$addresses = ipv4_subnet_members($nas["nas_address"]);

		foreach ($addresses as $address)
		{
			fwrite($fh, $nas["nas_ldapgroup"] . "\tNAS-IP-Address == $address\n");
		}
	}
	else
	{
		// hostname
		// need to fetch the associated IP address and then write to file

		fwrite($fh, $nas["nas_ldapgroup"] . "\tNAS-IP-Address == ". gethostbyname($nas["nas_address"]) ."\n");
	}


	// special case for localhost (only used when testing)
	if ($nas["nas_address"] == "127.0.0.1")
	{
		// radtest identified as 255.255.255.255
		fwrite($fh, $nas["nas_ldapgroup"] . "\tNAS-IP-Address == 255.255.255.255\n");
	}



	/*
		Write huntgroup conditions
	*/

	log_write("debug", "main", "Process Conditional Huntgroups for ". $nas["nas_hostname"] ."");


	if (is_array($nas["nas_conditions"]))
	{
		foreach ($nas["nas_conditions"] as $condition)
		{

			// determine the type of address
			if (preg_match("/^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:[.](?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$/", $nas["nas_address"]))
			{
				// single IP, write a rule
				fwrite($fh, $condition["cond_ldapgroup"] . "\tNAS-IP-Address == ". $nas["nas_address"] .", ". $condition["cond_attribute"] ."\n");
			}
			elseif (preg_match("/^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:[.](?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}\/[0-9]*$/", $nas["nas_address"]))
			{
				// subnet in CIDR notation
				// we need to calculate all the IP addresses in this subnet and then write them all to the configuration file

				$addresses = ipv4_subnet_members($nas["nas_address"]);

				foreach ($addresses as $address)
				{
					fwrite($fh, $condition["cond_ldapgroup"] . "\tNAS-IP-Address == $address, ". $condition["cond_attribute"] ."\n");
				}
			}
			else
			{
				// hostname
				// need to fetch the associated IP address and then write to file

				fwrite($fh, $condition["cond_ldapgroup"] . "\tNAS-IP-Address == ". gethostbyname($nas["nas_address"]) .", ". $condition["cond_attribute"] ."\n");
			}


			// special case for localhost (only used when testing)
			if ($nas["nas_address"] == "127.0.0.1")
			{
				// radtest identified as 255.255.255.255
				fwrite($fh, $condition["cond_ldapgroup"] . "\tNAS-IP-Address == 255.255.255.255, ". $condition["cond_attribute"] ."\n");
			}
		}
	}


	// spacer
	fwrite($fh, "\n");

}		        

fwrite($fh, "\n");
fclose($fh);



/*
	USERS FILE TO MAP GROUPS TO LDAP
*/

log_write("debug", "script", "Writing users configuration file ". $GLOBALS["config"]["freeradius_file_users"] ."");

if (!$fh = fopen($GLOBALS["config"]["freeradius_file_users"], "w"))
{
	log_write("error", "main", "Unable to open file ". $GLOBALS["config"]["freeradius_file_users"] ." for writing");
	die("Fatal Error");
}

fwrite($fh, "#\n");
fwrite($fh, "# FREERADIUS USER CONFIGURATION\n");
fwrite($fh, "# automatically generated by phpfreeradius - do not manually adjust as changes will be lost\n");
fwrite($fh, "#\n");
fwrite($fh, "# application version ". $GLOBALS["config"]["app_version"] . " configuration version $config_version\n");
fwrite($fh, "#\n");
fwrite($fh, "\n");

fwrite($fh, "#\n");
fwrite($fh, "# Map to LDAP groups\n");
fwrite($fh, "#\n");


// create array of each group
$data_huntgroups = array();

foreach ($data_nas as $nas)
{
	// default huntgroups
	$data_huntgroups[ $nas["nas_ldapgroup"] ] = 1;


	// conditional huntgroups
	if (is_array($nas["nas_conditions"]))
	{
		foreach ($nas["nas_conditions"] as $condition)
		{
			$data_huntgroups[ $condition["cond_ldapgroup"] ] = 1;
		}
	}	
}


// write group configuration to file
foreach (array_keys($data_huntgroups) as $ldapgroup)
{
	fwrite($fh, "DEFAULT Huntgroup-Name == $ldapgroup, Ldap-Group == \"cn=$ldapgroup,". $GLOBALS["config"]["ldap_groupdn"] ."\", User-Profile := \"cn=$ldapgroup,". $GLOBALS["config"]["ldap_groupdn"] ."\"\n");
	fwrite($fh, "\tFall-Through = no\n");
	fwrite($fh, "\n");
}


fwrite($fh, "#\n");
fwrite($fh, "# Authenticate Against LDAP\n");
fwrite($fh, "#\n");
fwrite($fh, "DEFAULT Auth-Type := Reject\n");
fwrite($fh, "\tReply-Message = \"Authentication denied - user does not belong to any suitable groups to access this NAS\"\n");
fwrite($fh, "\n");


fclose($fh);



/*
	Test FreeRadius configuration

	This is currently only supported in version 2.x.x and later. FreeRadius 1 did ship
	with a tool for checking, but this tool has been found to be broken on some distributions.
*/

if ($config["freeradius_format"] == "1")
{
	log_write("debug", "script", "Unable to test FreeRadius configuration, version 1 does not support this ability");
}
else
{
	/*
		Run Tests
	*/
	log_write("debug", "script", "Testing new FreeRadius configuration using ". $config["freeradius_test"] ."");

	exec($config["freeradius_test"], $exec_output, $exec_return_value);

	if ($exec_return_value)
	{
		// an error occured
		log_write("error", "script", "An error occured whilst testing new FreeRadius configuration! No reload will take place");


		// push error up via logs
		try
		{
			$client->log_write(time(), "FATAL", "FREERADIUS CONFIGURATION INVALID, NOT RELOADING.");
			$client->log_write(time(), "FATAL", "Execute ". $config["freeradius_test"] ." for more details and report to engineering");
		}
		catch (SoapFault $exception)
		{
			log_write("error", "script", "An unknown error (". $exception->getMessage() .") occured whilst pushing log messages up to FreeRadius");
		}

		die("Fatal Error");
	}
	else
	{
		// success!
		log_write("debug", "script", "FreeRadius configuration tested successfully!");
	}
}


/*
	Reload FreeRadius
*/

log_write("debug", "script", "Reloading FreeRadius with new configuration using ". $config["freeradius_reload"] ."");

exec($config["freeradius_reload"], $exec_output, $exec_return_value);

if ($exec_return_value)
{
	//
	// Note: This reload command often seems to return successful even when there is a failure, don't rely
	// on this, instead the checks of the configuration before and of the process afterwards are the best
	// way to verify that things are working.
	//

	log_write("error", "script", "Unable to confirm successful reload of FreeRadius, potentially a configuration generation problem");
}



/*
	Verify that FreeRadius is running
*/

log_write("debug", "script", "Verifing radiusd process is running...");


exec($config["freeradius_status"], $exec_output, $exec_return_value);

if ($exec_return_value)
{
	// failure!
	log_write("error", "script", "Process NOT FOUND, FreeRadius process appears not to be running!");


	// push error up via logs
	try
	{
		$client->log_write(time(), "FATAL", "FREERADIUS PROCESS MISSING");
		$client->log_write(time(), "FATAL", "Execute ". $config["freeradius_status"] ." on server to verify!");
	}
	catch (SoapFault $exception)
	{
		log_write("error", "script", "An unknown error (". $exception->getMessage() .") occured whilst pushing log messages up to FreeRadius");
	}


	// terminate
	die("Fatal Error");
}
else
{
	// Success!
	log_write("debug", "script", "Process OK, FreeRadius successfully reloaded with new configuration");
}




/*
	Report Success
*/

try
{
	if (!$client->set_update_version($config_version))
	{
		log_write("debug", "script", "Unable to confirm successfull application of configuration version $config_version");
		die("Fatal Error");
	}
}
catch (SoapFault $exception)
{
	log_write("error", "script", "An unexpected error occured ". $exception->getMessage() ."");
	die("Fatal Error");
}




?>
